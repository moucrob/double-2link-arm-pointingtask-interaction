% ONLY END POSITIONS OF THE END EFFECTORS OF PLAYER 1 AND 2 ARE REPRESENTED
% ASSUMING THEY ARRIVE THERE BY DOING A STRAIGHT PATH FROM THEIR STANDBY
% POSITION.
%%
clear all
clc
%% DIMENSIONS
width = 0.57; %m
height = 0.345;

method = 'straight lines';
standbyPos1 = [width + 0.02, 0.135]; %x,y
standbyPos2 = [-0.02, height - 0.135];

method = 'moving circles';
radiusEE = [1 1]*0.005; %doigt1 doigt2
durationMvmts = [1 1]; %sec

display = 0; %0 or 1 to plot the "(not) real time" trajectories
summary1 = 0;
summary2 = 1;

method = 'moving links';
distTablet = 0.25;
dimsArms = [ones(2,1)*0.32 ones(2,1)*0.5];
orig1x = 0.57/2 + 0.35/2; %later dont forget to add radius of the arm cylinder
orig1y = -((0.7-0.345)/2) - distTablet;
orig1 = [orig1x orig1y];
orig2x = 0.57/2 - 0.35/2; %later dont forget to add radius of the arm cylinder
orig2y = 0.345 + (0.7-0.345)/2 + distTablet;
orig2 = [orig2x orig2y];

%VISION ADDITION:
origVision1x = 0.57/2 ; origVision2x = origVision1x;
origVision1z = 0.40 ; origVision2z = origVision1z;
origVision1y = orig1y + 0.094;
origVision2y = orig2y - 0.094;
origVision1 = [origVision1x origVision1y origVision1z];
origVision2 = [origVision2x origVision2y origVision2z];

method = 'moving links with polyhedron forearms';
dimsArms3D = [ones(2,1)*0.32 ones(2,1)*0.5 ones(2,1)*0.075 ones(2,1)*0.06]; %(m)

method = 'moving links with polyhedron and fingers';
dimsArms3DwFing = [ones(2,1)*0.32 ...
            ones(2,1)*0.4 ones(2,1)*0.075 ones(2,1)*0.06 ...
            ones(2,1)*0.1 ones(2,2)*2*radiusEE(1)*cos(pi/4) ]; %(m) (logic below)
[whichAngle,lenFore,projectedLenFing] = whichDesignAngleRotY(dimsArms3DwFing(1,4),dimsArms3DwFing(1,5),dimsArms3DwFing(1,7),0.5,0);
dimsArms3DwFing(:,2) = ones(2,1)*lenFore;
[epsilonTot,O2toEEforIK]= perpendicularDecenteringEE(dimsArms3DwFing(1,3)/2,lenFore+projectedLenFing);
[epsilonFore,O2toMETforIK]= perpendicularDecenteringEE(dimsArms3DwFing(1,3)/2,lenFore);

%% SPLITTING
nbRowsRealWorld = 4;
nbColumnsRealWorld = 6; % +2 for the red button
nbPos = nbRowsRealWorld*nbColumnsRealWorld;

widthVerticalBands = width/(nbColumnsRealWorld+2);
widthHorizontalBands = height/nbRowsRealWorld;
realWorldDX = widthVerticalBands/2;
realWorldDY = widthHorizontalBands/2;

nbPossibleRequests = nbPos*(nbPos-1);

realWorldPosX = [3*realWorldDX];
for j=1:nbColumnsRealWorld-1
    realWorldPosX(j+1) = realWorldPosX(j) + widthVerticalBands ; end

realWorldPosY = [height - realWorldDY];
for i=1:nbRowsRealWorld-1
    realWorldPosY(i+1) = realWorldPosY(i) - widthHorizontalBands ; end

%% (anticipated) GRAPHICAL SUMMARY 1 (PART 1, definitions)
%Here is the BoxesWorld:
% xMinMax = [-1 nbColumnsRealWorld+1] ; yMinMax = [0 nbRowsRealWorld];
%(This codeline was used when I tried to plot kind of the real world,
%adding to more non-grided white columns to each side, so That i could
%represent the starting/standby positions...)
xMinMax = [0 nbColumnsRealWorld] ; yMinMax = [0 nbRowsRealWorld];

% requiredPointsGridX = xMinMax(2)-xMinMax(1)-1;
requiredPointsGridX = xMinMax(2)-xMinMax(1)+1;
% gridVecPointsX = linspace(xMinMax(1)+1, xMinMax(2)-1, requiredPointsGridX);
gridVecPointsX = linspace(xMinMax(1), xMinMax(2), requiredPointsGridX);

requiredPointsGridY = yMinMax(2)-yMinMax(1)+1;
gridVecPointsY = linspace(yMinMax(1), yMinMax(2), requiredPointsGridY);
[gridX, gridY] = meshgrid(gridVecPointsX, gridVecPointsY);
sizeBoxX_boxesWorld = gridVecPointsX(2) - gridVecPointsX(1);
sizeBoxY = gridVecPointsY(2) - gridVecPointsY(1);

offsetFromTop = 0.1 ;
sizeBoxY_boxesWorld = sizeBoxY - offsetFromTop;

%% STORAGE
nbTimesAPointIsTouched = 2*(nbPos-1);

% [nbRowsBoxesWorld, nbColumnsBoxesWorld, boxesWorldDX, boxesWorldDY] ...
% = matrixLayoutPointsInABox(nbTimesAPointIsTouched, sizeBoxX_boxesWorld, sizeBoxY_boxesWorld);

% boxesWorldPos = randomLayoutPointsInABox(nbTimesAPointIsTouched, sizeBoxX_boxesWorld, sizeBoxY_boxesWorld);

%Or I pick 46 pos among the 48 outputed by the (failing) finite element
%method: (to launch testdemoi in the subfolder distmesh)
%(Basically the FEM require an edge length threshold and iterate til it's
%reached. What I do, since I care about the number of nodes rather than
%this length is to encapsulate the loop into one about different trials for
%the edge length.)
step = 0.166666666666667; %generated by testdemoi
posFEM = [ -0.0000    0.4315;
   -0.0000    0.1404;
   -0.0000    0.8604;
         0         0;
         0    1.0000;
    0.0000    0.5697;
    0.0000    0.7245;
    0.0000    0.2770;
    0.1568    0.3307;
    0.1571    0.6671;
    0.1603    0.0000;
    0.1607    1.0000;
    0.2012    0.4991;
    0.2040    0.8329;
    0.2045    0.1661;
    0.3219    0.6652;
    0.3220    0.3341;
    0.3269    1.0000;
    0.3270    0.0000;
    0.4015    0.4998;
    0.4023    0.8319;
    0.4026    0.1679;
    0.5000    0.0000;
    0.5000    1.0000;
    0.5000    0.3342;
    0.5000    0.6656;
    0.5974    0.1679;
    0.5977    0.8319;
    0.5985    0.4998;
    0.6730    0.0000;
    0.6731    1.0000;
    0.6780    0.3341;
    0.6781    0.6652;
    0.7955    0.1661;
    0.7960    0.8329;
    0.7988    0.4991;
    0.8393    1.0000;
    0.8397    0.0000;
    0.8429    0.6671;
    0.8432    0.3307;
    1.0000         0;
    1.0000    1.0000;
    1.0000    0.1404;
    1.0000    0.8604;
    1.0000    0.4315;
    1.0000    0.5697;
    1.0000    0.7245;
    1.0000    0.2770];
for i=1:2; posFEM(ceil(size(posFEM,1)*rand()),:)=[];end
%Then I shift the lattice so that he doesn't touch the borderlines
unityX = sizeBoxX_boxesWorld - step;
unityY = sizeBoxY_boxesWorld - step - 0.1; % to see the coordinates text
posFEM_scaled(:,1) = posFEM(:,1)*unityX;
posFEM_scaled(:,2) = posFEM(:,2)*unityY;
boxesWorldPos = posFEM_scaled;
shift = step/2;

posMatObject = cell(nbRowsRealWorld, nbColumnsRealWorld); posVec = []; %nbPos x 2
for i=1:nbRowsRealWorld
    for j=1:nbColumnsRealWorld
        posMatObject{i,j}.realWorldPos = [realWorldPosX(j), realWorldPosY(i)];
            % (For later :)
            OrigX = j-1 + shift ; 
            OrigY = nbRowsRealWorld-(i-1)-1 + shift;%+sizeBoxY_boxesWorld;
            posMatObject{i,j}.howManyTouch = [];
            
%             for m=1:nbRowsBoxesWorld
%                 for n=1:nbColumnsBoxesWorld
%                     posMatObject{i,j}.howManyTouch(end+1,1).boxesWorldPos ...
%                   = [OrigX+n*boxesWorldDX OrigY-m*boxesWorldDY];
%                     posMatObject{i,j}.howManyTouch(end,1).classified = 'n';
%                     %will become yes when this touch will be classified
%                     %(safe/unsafe) and when it will be assigned to a request.
%                 end
%             end
            
            for k=1:nbTimesAPointIsTouched
                posMatObject{i,j}.howManyTouch(end+1,1).boxesWorldPos ...
              = [OrigX+boxesWorldPos(k,1) OrigY+boxesWorldPos(k,2)];
                posMatObject{i,j}.howManyTouch(end,1).classified = 'n';
                %will become yes when this touch will be classified
                %(safe/unsafe) and when it will be assigned to a request.
            end

        posVec(end+1, :) = [realWorldPosX(j), realWorldPosY(i)];
    end
end

%% COMBINATORICS
requestsRealWorld = cell(nbPossibleRequests,2); %one doublet for player1 one other for p2
for i=1:nbPos
    if i==1 ; borneinf = 1 ; else ; borneinf = (i-1)*(nbPos-1)+1; end
    for j = borneinf : borneinf + (nbPos - 2)
        requestsRealWorld{j, 1} = posVec(i,:); end
    
    %deletion of the alreardy chosen position in the remaining ones
    cop = posVec ; cop(i,:) = [];
    
    for k = 1:nbPos-1
        if i==1
            row = k;
        else
            row = (i-1)*(nbPos-1)+k;
        end
        requestsRealWorld{row, 2} = cop(k,:);
    end
end

%% GEOMETRIC INTERSECTION PREDICTION
% https://stackoverflow.com/questions/27928373/how-to-check-whether-two-lines-intersect-or-not

% figure
% axis([standbyPos2(1) standbyPos1(1) 0 height]) ; hold on
intersect = []; args = [standbyPos1, standbyPos2];
for i=1:nbPossibleRequests
    args(5:8) = [requestsRealWorld{i,1} requestsRealWorld{i,2}];
%     intersect(i,1) = do2segmentsIntersect(args);
%     intersect(i,1) = do2movingCirclesIntersect(args,radiusEE,durationMvmts,display);
%     intersect(i,1) = do2moving2DarmsIntersect(args,radiusEE,dimsArms,orig1,orig2,durationMvmts,display);
%     intersect(i,1) = do2_2Dmoving_3DforeArmsIntersect(args,radiusEE,dimsArms3D,orig1,orig2,durationMvmts,display);
%     if display
        disp(['Request n°',num2str(i)])
        disp(['Simulating all the possibilities, ',num2str(100*i/nbPossibleRequests),' achieved.'])
%     end
    intersect(i,1) = do2_2Dmoving_3DforeArms_decentered3DfingersIntersect(args,radiusEE,dimsArms3DwFing,orig1,orig2,origVision1,origVision2,durationMvmts,whichAngle,lenFore,projectedLenFing,epsilonTot,epsilonFore,O2toEEforIK,O2toMETforIK,display);

%     plot([args(1) args(5)], [args(2) args(6)]); hold on
%     plot([args(3) args(7)], [args(4) args(8)]); hold on
%         % to verify that a request and its intersection prediction match well:
%         drawnow ; intersect(i)
% 	pause(20) %; clc

    %classification of both a touch among those assigned to position1
    %and of a touch among those assigned to position2, into the BoxesWorld
    [m1,n1,m2,n2] = bijecNtoN2xN2(i, nbRowsRealWorld,nbColumnsRealWorld); %output indexes of the real positions
    %that constitute request i.
    for j=1:nbTimesAPointIsTouched
        if posMatObject{m1,n1}.howManyTouch(j).classified == 'n' %not yet classified
            posMatObject{m1,n1}.howManyTouch(j).cat = intersect(i);
            posMatObject{m1,n1}.howManyTouch(j).request = i;
            posMatObject{m1,n1}.howManyTouch(j).classified = 'y';
            posMatObject{m1,n1}.howManyTouch(j).reachedby = 1;
            break
        end  
    end
    for j=1:nbTimesAPointIsTouched %same thing for pos2
        if posMatObject{m2,n2}.howManyTouch(j).classified == 'n'
            posMatObject{m2,n2}.howManyTouch(j).cat = intersect(i);
            posMatObject{m2,n2}.howManyTouch(j).request = i;
            posMatObject{m2,n2}.howManyTouch(j).classified = 'y';
            posMatObject{m2,n2}.howManyTouch(j).reachedby = 2;
            break
        end  
    end
end

%% GRAPHICAL SUMMARY 1 (PART 2, plot)
if summary1
    standbyPos2BoxesWorld = (nbRowsRealWorld/height)*[standbyPos2(2) ; standbyPos1(2)]; %TODO : create a function for this bullshit
    standbyPosBoxesWorld = [xMinMax' , standbyPos2BoxesWorld];
    shiftText = 0.01;
    palette = colormap(jet(nbPossibleRequests));
    palette = datasample(palette,nbPossibleRequests,'Replace',false);

    figure
    title(['Graphical summary : bumping-leading Vs. safe movement, ', ...
           'based on intersection of traight path lines.'])
    axis([xMinMax yMinMax]); hold on
    set(gca,'XTick',[]) ; set(gca,'YTick',[]) % remove numerotation
    % The grid :
    pcolor(gridX, gridY, zeros( numel(gridVecPointsY), numel(gridVecPointsX) ) )
    colormap(gray(2)) ; hold on

    %First, the links :
    requestsBoxesWorld = cell(nbPossibleRequests,3);
    for k=1:nbPossibleRequests
        [i1,j1,i2,j2] = bijecNtoN2xN2(k, nbRowsRealWorld,nbColumnsRealWorld);
        m = 1 ; while posMatObject{i1,j1}.howManyTouch(m).request ~= k
            m = m+1;
        end ; requestsBoxesWorld{k,1} = posMatObject{i1,j1}.howManyTouch(m).boxesWorldPos;
        requestsBoxesWorld{k,3} = posMatObject{i1,j1}.howManyTouch(m).cat;
        m = 1 ; while posMatObject{i2,j2}.howManyTouch(m).request ~= k
            m = m+1;
        end ; requestsBoxesWorld{k,2} = posMatObject{i2,j2}.howManyTouch(m).boxesWorldPos;
        plot([requestsBoxesWorld{k,1}(1) requestsBoxesWorld{k,2}(1)], ...
             [requestsBoxesWorld{k,1}(2) requestsBoxesWorld{k,2}(2)], ...
             '-','Color',palette(k,:)) ; hold on
    end

    %Second, the markers :
    for k=1:nbPossibleRequests
        cat = requestsBoxesWorld{k,3};
        x1 = requestsBoxesWorld{k,1}(1); % Player 1
        y1 = requestsBoxesWorld{k,1}(2);
        x2 = requestsBoxesWorld{k,2}(1); % Player 2 
        y2 = requestsBoxesWorld{k,2}(2);
        if cat == 1 %bump;
            styl = '^';
        else %cat=0, safe
            styl = 'o';
        end
        plot(x1, y1, styl, 'MarkerFaceColor', palette(k,:), ...
             'MarkerEdgeColor', palette(k,:), 'MarkerSize', 9) ; hold on
        plot(x2, y2, styl, 'MarkerFaceColor', palette(k,:), ...
             'MarkerEdgeColor', palette(k,:), 'MarkerSize', 9) ; hold on
        text( x1 - shiftText, y1 + shiftText, '1', ...
             'Color','white', 'FontSize', 6, 'FontWeight', 'bold' )
        text( x2 - shiftText, y2 + shiftText, '2', ...
             'Color','white', 'FontSize', 6, 'FontWeight', 'bold' ); hold on
    %     drawnow ; pause(0.5)
    end

    %Finally, the labels of the boxes :
    for i=1:nbRowsRealWorld
        for j=1:nbColumnsRealWorld
            x = j-0.9; y = nbRowsRealWorld-(i-1)-offsetFromTop;
            text(x,y, ['( ',num2str(posMatObject{i,j}.realWorldPos(1)),' ; ', ...
                 num2str(posMatObject{i,j}.realWorldPos(2)),' ) '], ...
                 'FontWeight', 'bold', 'FontSize', 11)
        end
    end
end
%% GRAPHICAL SUMMARY 2
%I represent 6x4 touchscreens. In each, there are 6x4 rectangles (total 576
%rectangles) and always 1 black, being the ~CENTER POSITION of the piece
%where Player1 goes. All the other of the sub-touch screen are either green
%or red, depending on whether Player2 will lead to a bumping/safe move by
%going there.
if summary2
    summaryIntervalsX = nbColumnsRealWorld^2;
    summaryIntervalsY = nbRowsRealWorld^2;
    points2X = 0:1:summaryIntervalsX ; points2Y = 0:1:summaryIntervalsY;
    [grid2X, grid2Y] = meshgrid(points2X, points2Y);
    points2Xbig = 0:nbColumnsRealWorld:summaryIntervalsX;
    points2Ybig = 0:nbRowsRealWorld:summaryIntervalsY;
    [grid2Xbig, grid2Ybig] = meshgrid(points2Xbig, points2Ybig);

    colors = ['g','r','m','k','c']; %0=safe=green, 1=bump=red, 2=occl=magenta, 4=both=cyan
    %Hence I have to disable the distinction between 1 occluded by 2 and 2
    %occluded by 1 in order to use my color indexation:
    intersectSimplified = [];
    for i=1:numel(intersect)
        if sum(intersect(i) == [0 10]) ~= 0 %if intersect(i)'s value is either 0 or 10
            intersectSimplified(i,1) = intersect(i)/10;
        elseif sum(intersect(i) == [21 22]) ~= 0 %if intersect(i)'s value is either 21 or 22
            intersectSimplified(i,1) = 2;
        else %value is either 31 or 32
            intersectSimplified(i,1) = 4;
        end
    end
    
    figure
    title(['Graphical summary : bumping-leading Vs. safe movement, ', ...
           'based on intersection of traight path lines.'])
    %line to be moved after the pcolor : (keeping it here for now to build the code)
    set(gca,'XTick',[]) ; set(gca,'YTick',[]) % remove numerotation
    %The grid :
    g(1) = pcolor(grid2X, grid2Y, zeros( numel(points2Y), numel(points2X) ) );
    colormap(gray(2)) ; hold on

    subTouchScreenPosPattern = [];
    for i=summaryIntervalsY:-1:summaryIntervalsY-nbRowsRealWorld+1
        for j=1:nbColumnsRealWorld
            subTouchScreenPosPattern(end+1,:) = [j,i];
        end
    end     

    subTouchScreen = 0;
    for i=1:nbPos-1:nbPossibleRequests
        %PLOTING FOR PLAYER1
    %     disp(['SubTouchScreen = ', num2str(subTouchScreen)]) %debug
        [iSubP1, jSubP1, ~, ~] = bijecNtoN2xN2(i, nbRowsRealWorld,nbColumnsRealWorld); %location of the black rectangle within the subTouchScreen
    %     disp(['iSubP1 = ', num2str(iSubP1),', jSubP1 = ',num2str(jSubP1)]) %debug
        %Hence it is also the (i,j)th rectangle of the (i,j)th subTouchScreen
        %thanks to the way we made our storage (see requestsRealWorld).
    %     fill(,,'Color',colors(intersect(i)+1))
        iP1 = (iSubP1-1)*nbRowsRealWorld + iSubP1;
        jP1 = (jSubP1-1)*nbColumnsRealWorld + jSubP1;
    %     disp(['iP1 = ', num2str(iP1),', jP1 = ',num2str(jP1)]) %debug
        %vertices of the black rectangle we have to fill
        xRecP1 = jP1+[-1 0 0 -1];
    %     disp(['xRecP1 = ',num2str(xRecP1)])
        yRecP1 = nbRowsRealWorld^2-iP1+[0 0 1 1];
    %     disp(['yRecP1 = ',num2str(yRecP1)])
        fill(xRecP1,yRecP1,colors(4)) %filling of all the Player1 locations
        hold on

        %PLOTING FOR PLAYER2
        subTouchScreen = subTouchScreen+1;
        disp(['subTouchScreen = ',num2str(subTouchScreen)])
        %Translation of the subTouchScreenPosPattern onto the right
        %subTouchScreen:
        iSubP2 = ceil(subTouchScreen/nbColumnsRealWorld);
        disp(['iSubP2 = ',num2str(iSubP2)])
        jSubP2 = mod(subTouchScreen,nbColumnsRealWorld); %+1 is a trick, otherwise mod(6,6) = 0 instead of 6... :/
            if jSubP2 == 0 ; jSubP2 = nbColumnsRealWorld ; end
        disp(['jSubP2 = ',num2str(jSubP2)])
        subTouchScreenPos = [];
        subTouchScreenPos(:,1) = subTouchScreenPosPattern(:,1) + (jSubP2-1)*nbColumnsRealWorld;
        subTouchScreenPos(:,2) = subTouchScreenPosPattern(:,2) - (iSubP2-1)*nbRowsRealWorld;
        subTouchScreenPos(subTouchScreen,:) = []; %Location already occupied by Player1!

        for j=1:nbPos-1 %(dim of the new subTouchScreenPos)
            xRecP2 = subTouchScreenPos(j,1)+[-1 0 0 -1];
            yRecP2 = subTouchScreenPos(j,2)+[-1 -1 0 0];
            fill(xRecP2,yRecP2,colors( intersectSimplified(i-1+j)+1 ))
        end
%         pause(2)
    end
    
    %In order to better see the separation between the several touchscreens:
    % g(2) = pcolor(grid2Xbig, grid2Ybig, zeros( numel(gridVecPointsY), numel(gridVecPointsX) ) );
    % g(2).LineWidth = 2.5 ; %colormap(gray(2)) ; hold on
    linewidth = 2;
    %Horizontal lines:
    horzLine = [[0 ; summaryIntervalsX], [0 ; 0]];
    for i = 1:nbRowsRealWorld+1
        plot(horzLine(:,1),horzLine(:,2),'k-','LineWidth',linewidth) ; hold on
        horzLine(:,2) = horzLine(:,2)+nbRowsRealWorld;
    end
    %Vertical lines:
    vertLine = [[0 ; 0], [0 ; summaryIntervalsY]];
    for j = 1:nbColumnsRealWorld+1
        plot(vertLine(:,1),vertLine(:,2),'k-','LineWidth',linewidth) ; hold on
        vertLine(:,1) = vertLine(:,1)+nbColumnsRealWorld;
    end
end
    
    
    
    
    